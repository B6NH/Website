<h1>Rexx</h1>

<p>
  Rexx is a simple interpreted programming language.
  It was designed with ease of use in mind.
  It is most commonly used for word processing tasks.
</p>

<ul>

  <li>
    In Rexx, <b>variables</b> don't have to be declared.
    Assignments, as in many other languages, are denoted by the symbol <em>=</em>.
    Language has built-in functions for basic mathematical operations such
    as addition, subtraction, multiplication, division, etc.
    Rexx program starts when the first instruction is encountered and ends
    with an <em>exit</em> statement.
    <pre><code>/* Assignments */
a = 8
b = 2 ; c = 3

/* The 'say' instruction prints the data to the screen */
say a + b * c

/* Mathematical operations */
say 'Integer division:' 15 % 6
say 'Remainder:' 20 // 16
say 'Power:' 2 ** 8


/* End script */
exit 0
</code></pre>
<pre class="coutput"><samp>14
Integer division: 2
Remainder: 4
Power: 256
</samp></pre>
  </li>

  <li>
      The language has a few <b>conditional statements</b>.
    <pre><code>/* Conditional statement */
if 5 > 12 then
  say 'Five is greater than twelve' /* 1 statement */
else
  /* 2 or more statements have to be placed inside 'do - end' block. */
  do
    say 'Five is not greater than twelve'
    say 'It is really not'
  end

say '---'

/* Switch (select) statement */
a = 5

select
  when a = 4 then
    say 'Four'
  when a = 5 then
    say 'Five'
  when a = 6 then
    do
      say 'Number'
      say 'Six'
    end
  otherwise
    /* If there are multiple instructions after 'otherwise',
       they don't have to be placed in a do-end block */
    say 'Some'
    say 'Other'
    say 'Number'
end

exit 0
</code></pre>
<pre class="coutput"><samp>Five is not greater than twelve
It is really not
---
Five
</samp></pre>
  </li>

  <li>
    Several types of <b>loops</b> are available.
    <pre><code>/* While loop */
i = 0
do while i \= 3 /* while i is not equal to 3 */
  say 'While' i
  i = i + 1
end

say '---'

/* For loop */
do i=1 to 3 /* add 'by x' to specify step */
  say 'For' i
end

return 0
</code></pre>
<pre class="coutput"><samp>While 0
While 1
While 2
---
For 1
For 2
For 3
</samp></pre>
  </li>

  <li>
    Rexx also has <b>unstructured</b> control instructions.
    <pre><code>/* Forever loop */
z = 1
do forever
 say 'Forever' z
 z = z + 1
 if z > 2 then
   leave /* break forever loop */
end

say '---'

/* Do while loop */
i = 5
do until i = 5
  say 'Do until' /* displays only once */
end

say '---'

/* Iterate (continue) statement */
do i=1 to 5
  if i < 4 then
    iterate /* go to the beginning of the loop */
  say 'Iterate' i
end

say '---'

/* Signal statement */
do i=1 to 10
  if i = 9 then
    signal mylabel /* go to 'mylabel' label */
end

/* Label */
mylabel:
  say 'Label:' i

exit 0
</code></pre>
<pre class="coutput"><samp>Forever 1
Forever 2
---
Do until
---
Iterate 4
Iterate 5
---
Label: 9
</samp></pre>
  </li>

  <li>
    <b>Arrays</b> are data structures that allow to store and process collections of values.
    They are easy to work with and can be used in many ways.
    <pre><code>/* Initialize array and set all values to 7 */
myarray. = 7

/* Print some values */
do i=1 to 3
  say myarray.i
end

/* After initialization all possible indices have the same value */
say 'At 58:' myarray.58
say 'At cherries:' myarray.cherries

say '---'

/* Arrays don't have to be initialized */
players.5 = 'Saida'
say 'Player 5:' players.5

/* Unitialized element is displayed as PLAYERS.8 */
say 'Player 8:' players.8

say '---'

/* Index 0 is typically used to store the array size. */
fruits.0 = 3
fruits.1 = 'apple'
fruits.2 = 'orange' ; fruits.3 = 'peach'

/* Show array contents */
do j = 1 to fruits.0
  say fruits.j
end

say '---'

/* If the array was initialized, a while loop can be used to process it */
colors. = ''
colors.1 = 'red'
colors.2 = 'blue'
colors.3 = 'green'

/* The value '' symbolizes the end of the array and therefore
   cannot be its regular element. */
do i = 1 while colors.i <> '' /* Symbols '<>' and '\=' mean 'unequal'.*/
  say colors.i
end

say '---'

/* Arrays can have any number of dimensions */
animals.0 = 2

animals.1.name = 'Lion'
animals.1.color = 'yellow'

animals.2.name = 'Tiger'
animals.2.color = 'orange'

do i = 1 to animals.0
  say 'Name: ' animals.i.name
  say 'Color: ' animals.i.color
end

exit 0
</code></pre>
<pre class="coutput"><samp>7
7
7
At 58: 7
At cherries: 7
---
Player 5: Saida
Player 8: PLAYERS.8
---
apple
orange
peach
---
red
blue
green
---
Name:  Lion
Color:  yellow
Name:  Tiger
Color:  orange
</samp></pre>
  </li>

  <li>
    Rexx allows the programmer to define new <b>functions</b> and <b>subroutines</b>.
    <pre><code>/* Functions can be called using parentheses or 'call' instruction */
number = my_function()
call my_function

/* Assigned value */
say number

/* If a function is used with the word call,
   the value it returns is stored in a special
   'result' variable. */
say result

say '---'

/* Subroutines should only be called using the 'call' instruction */
call my_subroutine

/* When the subroutine is called, the 'result'
   variable is reset and has a default value of RESULT */
say result

exit 0

/* Definitions are placed after the exit statement
   Each of them ends with a return statement */

/* Functions return value */
my_function:
  say 'Function'
  return 12

/* Subroutines don't have return value */
my_subroutine:
  say 'Subroutine'
  return
</code></pre>
<pre class="coutput"><samp>Function
Function
12
12
---
Subroutine
RESULT
</samp></pre>
  </li>

  <li>
    Functions and subroutines can take <b>arguments</b>.
    To limit the visibility of variables and reduce the risk of errors,
    the word <b>procedure</b> may be used.
    <pre><code>global_var = 20
global_var2 = 30
global_var3 = 50

call add_numbers 5, 6
sum = add_numbers(8,4)

say result
say sum

call show_variable

say '---'

call double_show "I'm Not Tired Yet"

say '---'

/* 2*3*20 */
say 'Product:' multiply_global(2, 3)

exit 0

add_numbers:
  arg a, b
  return a + b

/* By default, functions and
   subroutines have access to all variables */
show_variable:
  say 'Global variable:' global_var
  return

/* Limit the visibility of variables with the 'procedure' statement */
double_show: procedure
  parse arg text /* Use the parse statement to make the string unmodified */
  do i=1 to 2
    say text
  end
  /* The variable is not visible due to the use of the 'procedure' instruction */
  say 'Global variable in procedure:' global_var
  return

/* An 'explicit' instruction to make certain variables visible. */
multiply_global: procedure expose global_var global_var2
  arg a, b
  say 'Variables inside multiply:' global_var global_var2 global_var3
  return a * b * global_var
</code></pre>
<pre class="coutput"><samp>11
12
Global variable: 20
---
I'm Not Tired Yet
I'm Not Tired Yet
Global variable in procedure: GLOBAL_VAR
---
Variables inside multiply: 20 30 GLOBAL_VAR3
Product: 120
</samp></pre>
  </li>

</ul>
