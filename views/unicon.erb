<h1>Unicon</h1>

<p>
  Unicon is a very high-level programming language
  with goal-directed evaluation. Control flow is based
  on the action success or failure. Language also makes
  extensive use of generators.
</p>

<ul>

  <li>
    To compile and <b>run</b> Unicon program save the source
    code in a file with the extension .icn and at the
    command line type <code>unicon myfilename.icn -x</code>.
  </li>

  <li>
    Unicon program starts with the <em><b>main</b></em> function.
    <pre><code>procedure main()
  write("Hello World")
end
</code></pre>
<pre class="coutput"><samp>Hello World
</samp></pre>
  </li>

  <li>
    Operator <em>:=</em> is used for assignments.
    <b>Variables</b> may or may not be declared before use.
    Lines that start with a <em>#</em> sign are comments.
    <pre><code>procedure main()

  # Optional variable declaration
  local a, b

  # Semicolon is used to separate statements on a single line
  a := 15 ; b := 23

  write(a," + ",b," = ",a + b)

end
</code></pre>
<pre class="coutput"><samp>15 + 23 = 38
</samp></pre>
  </li>

  <li>
    Control structure <em><b>every</b></em> executes a block
    of code for all values returned by the generator.
    It can be used to create loops.
    <pre><code>procedure main()

  sum := 0 ; product := 1

  # Expression '1 to 5' generates values from 1 to 5,
  # which are assigned to 'i' and used inside loop
  every i := 1 to 5 do {
    sum +:= i
    product *:= i
  }

  write(sum)
  write(product)

end
</code></pre>
<pre class="coutput"><samp>15
120
</samp></pre>
  </li>

  <li>
    <b>Functions</b> are defined using the word <em>procedure</em>.
    The argument types may be specified, but it is not necessary.
    Simple types are passed by value and compound types by reference.
    <pre><code>procedure main()
  write(subtract(100,25))
  write(addAndMultiply(7,12))
  write(myAdd())
end

# Parameters without defined types
procedure subtract(a,b)
  return a - b
end

# Explicitly defined types
procedure addAndMultiply(a:integer,b:integer)
  return a + b + a * b
end

# Default argument values
procedure myAdd(p:5,d:integer:12)
  return p + d
end
</code></pre>
<pre class="coutput"><samp>75
103
17
</samp></pre>
  </li>

  <li>
    <b>Tables</b> are the basic compound type in the Unicon language.
    They are unordered collections of values that are accessed by keys.
    <pre><code>procedure main()

  # Initialize table
  myTable := table()

  # Set values
  myTable["color"] := "red"
  myTable["location"] := "east"
  myTable["animal"] := "lion"

  write("Values: ",myTable["color"],", ", myTable["location"])

  write("---")

  # Table can have default value
  numbers := table(2)
  numbers["first"] := 5
  numbers["second"] := 10

  write(numbers["first"])
  write(numbers["second"])
  write("Default value: ",numbers["otherkey"])

  write("---")

  # Insert new value
  insert(numbers,"newValue",123)

  write("New value: ",numbers["newValue"])

  # Delete value
  delete(numbers,"newValue")

  write("After deletion: ",numbers["newValue"])

  write("---")

  # Check if the key exists in the table
  if member(myTable,"color") then {
    write("Key ","\"color\""," exists")
  }

  # Use asterisk to check table size
  write("Table size: ",*myTable)

  write("Table elements:")

  # Exclamation mark generates all values from the table
  every element := !myTable do {
    write(element)
  }

  write("---")

  # The question mark takes random value from the table
  write(?myTable)

end
</code></pre>
<pre class="coutput"><samp>Values: red, east
---
5
10
Default value: 2
---
New value: 123
After deletion: 2
---
Key "color" exists
Table size: 3
Table elements:
lion
red
east
---
lion
</samp></pre>
  </li>

  <li>
    <b>Lists</b> are ordered collections of values with dynamic size.
    <pre><code>procedure main()
end
</code></pre>
<pre class="coutput"><samp>
</samp></pre>
  </li>

  <li>
    <b>Records</b>
    <pre><code>procedure main()
end
</code></pre>
<pre class="coutput"><samp>
</samp></pre>
  </li>

  <li>
    <b>OOP</b>
    <pre><code>procedure main()
end
</code></pre>
<pre class="coutput"><samp>
</samp></pre>
  </li>

</ul>
